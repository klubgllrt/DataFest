# Each of those periods is recorded on a separate row in the data frame.
# With dynamic data, we can use 'network.extract()' to get a network
# that only contains elements active at a given point/time interval.
# Plot the network ignoring time (all nodes & edges that were ever present):
plot(short.stergm.sim)
# Plot the network at time 1 (at=1):
plot( network.extract(short.stergm.sim, at=1) )
# Plot nodes & edges active for the entire period (`rule=all`) from 1 to 5:
plot( network.extract(short.stergm.sim, onset=1, terminus=5, rule="all") )
#Plot nodes & edges active at any point (`rule=any`) between 1 and 10:
plot( network.extract(short.stergm.sim, onset=1, terminus=10, rule="any") )
# Let's make a quick d3 animation from the example network:
render.d3movie(short.stergm.sim,displaylabels=TRUE)
# Next, we will create and animate our own dynamic network.
# Dynamic network object can be generated in a number of ways: from
# a set of networks/matrices representing different time points, or from
# data frames/matrices with node lists and edge lists indicating when each
# is active, or when they switch state. See ?networkDynamic for more information.
net3
plot(net3)
vs <- data.frame(onset=0, terminus=50, vertex.id=1:17)
es <- data.frame(onset=1:49, terminus=50,
head=as.matrix(net3, matrix.type="edgelist")[,1],
tail=as.matrix(net3, matrix.type="edgelist")[,2])
head(vs)
head(es)
# Combine our base network with the edge and node longitudinal data:
net3.dyn <- networkDynamic(base.net=net3, edge.spells=es, vertex.spells=vs)
# Plot the network (all elements present at any time point):
plot(net3.dyn, vertex.cex=(net3 %v% "audience.size")/7, vertex.col="col")
# Plot static images showing network evolution:
compute.animation(net3.dyn, animation.mode = "kamadakawai",
slice.par=list(start=0, end=49, interval=10,
aggregate.dur=10, rule='any'))
# Show time evolution through static images at different time points:
filmstrip(net3.dyn, displaylabels=F, mfrow=c(2, 3),
slice.par=list(start=0, end=49, interval=10,
aggregate.dur=10, rule='any'))
# We can pre-compute the animation coordinates (otherwise they get calculated when
# you generate the animation). Here 'animation.mode' is the layout algorithm -
# one of "kamadakawai", "MDSJ", "Graphviz"and "useAttribute" (user-generated).
# Here 'slice.par' is a list of parameters controlling how the network visualization
# moves through time. The parameter 'interval' is the time step between layouts,
# 'aggregate.dur' is the period shown in each layout, 'rule' is the rule for
# displaying elements (e.g. 'any': active at any point during that period,
# 'all': active during the entire period, etc.)
# Let's make an actual animation:
compute.animation(net3.dyn, animation.mode = "kamadakawai",
slice.par=list(start=0, end=50, interval=1,
aggregate.dur=1, rule='any'))
render.d3movie(net3.dyn, usearrows = F,
displaylabels = F, label=net3 %v% "media",
bg="#ffffff", vertex.border="#333333",
vertex.cex = degree(net3)/2,
vertex.col = net3.dyn %v% "col",
edge.lwd = (net3.dyn %e% "weight")/3,
edge.col = '#55555599',
vertex.tooltip = paste("<b>Name:</b>", (net3.dyn %v% "media") , "<br>",
"<b>Type:</b>", (net3.dyn %v% "type.label") ),
edge.tooltip = paste("<b>Edge type:</b>", (net3.dyn %e% "type"), "<br>",
"<b>Edge weight:</b>", (net3.dyn %e% "weight" ) ),
launchBrowser=T, filename="Media-Network-Dynamic.html",
render.par=list(tween.frames = 30, show.time = F),
plot.par=list(mar=c(0,0,0,0)) )
# In addition to dynamic nodes and edges, 'ndtv' takes dynamic attributes.
# We could have added those to the 'es' and 'vs' data frames above.
# However, the plotting function can also evaluate parameters
# and generate dynamic arguments on the fly. For example,
# function(slice) { do some calculations with slice } will perform operations
# on the current time slice network, letting us change parameters dynamically.
# See the node size below:
compute.animation(net3.dyn, animation.mode = "kamadakawai",
slice.par=list(start=0, end=50, interval=4,
aggregate.dur=1, rule='any'))
render.d3movie(net3.dyn, usearrows = F,
displaylabels = F, label=net3 %v% "media",
bg="#000000", vertex.border="#dddddd",
vertex.cex = function(slice){ degree(slice)/2.5 },
vertex.col = net3.dyn %v% "col",
edge.lwd = (net3.dyn %e% "weight")/3,
edge.col = '#55555599',
vertex.tooltip = paste("<b>Name:</b>", (net3.dyn %v% "media") , "<br>",
"<b>Type:</b>", (net3.dyn %v% "type.label") ),
edge.tooltip = paste("<b>Edge type:</b>", (net3.dyn %e% "type"), "<br>",
"<b>Edge weight:</b>", (net3.dyn %e% "weight" ) ),
launchBrowser=T, filename="Media-Network-even-more-Dynamic.html",
render.par=list(tween.frames = 25, show.time = F) )
detach("package:ndtv")
detach("package:sna")
detach("package:networkDynamic")
detach("package:network")
# ================ 10. Plotting networks on a geographic map ================
# The example below plots a network on a map using base R and mapping libraries.
# Note that for those familiar with it, the package 'ggplot2' may provide
# a more flexible way of doing this. Things there work similarly to below,
# but you would use borders() to plot the map and geom_path() for the edges.
rm(list = ls()) # clear the workspace
# In order to plot on a map, we'll need two additional packages.
# If you do not already have them, install those now:
# install.packages("maps")
# install.packages("geosphere")
library("maps")
library("geosphere")
# Package 'maps' has built-in maps it can plot for you. For example:
# ('col' is map fill, 'border' is  border color, 'bg' is  background color)
par(mfrow = c(2,2))
map("usa", col="tomato",  border="gray10", fill=TRUE, bg="gray30")
map("state", col="orange",  border="gray10", fill=TRUE, bg="gray30")
map("county", col="palegreen",  border="gray10", fill=TRUE, bg="gray30")
map("world", col="skyblue",  border="gray10", fill=TRUE, bg="gray30")
dev.off()
# The data we will use contains US airports and flights among them.
# The airport file includes info about latitude and longitude.
# If we did not have those, we could use 'geocode()' from 'ggmap'
# to get latitude and longitude for an address.
airports <- read.csv("./Data Files/Dataset3-Airlines-NODES.csv", header=TRUE)
flights <- read.csv("./Data Files/Dataset3-Airlines-EDGES.csv", header=TRUE, as.is=TRUE)
head(flights)
head(airports)
# Select only large airports: ones with more than 10 connections in the data.
tab <- table(flights$Source)
big.id <- names(tab)[tab>10]
airports <- airports[airports$ID %in% big.id,]
flights  <- flights[flights$Source %in% big.id &
flights$Target %in% big.id, ]
# Plot a map of the united states:
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
# Add a point on the map for each airport:
points(x=airports$longitude, y=airports$latitude, pch=19,
cex=airports$Visits/80, col="orange")
# Generate edge colors: lighter color means higher flight volume.
col.1 <- adjustcolor("orange red", alpha=0.4)
col.2 <- adjustcolor("orange", alpha=0.4)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
# For each flight, we will generate the coordinates of an arc that connects
# its star and end point, using gcIntermediate() from package 'geosphere'.
# Then we will plot that arc over the map using lines().
for(i in 1:nrow(flights))  {
node1 <- airports[airports$ID == flights[i,]$Source,]
node2 <- airports[airports$ID == flights[i,]$Target,]
arc <- gcIntermediate( c(node1[1,]$longitude, node1[1,]$latitude),
c(node2[1,]$longitude, node2[1,]$latitude),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
}
# ================ |-------------| ================
View(flights)
View(flights)
View(airports)
View(airports)
View(node1)
View(node1)
View(node2)
View(node2)
View(arc)
View(arc)
rm(list = ls()) # clear the workspace
library("maps")
library("geosphere")
# Package 'maps' has built-in maps it can plot for you. For example:
# ('col' is map fill, 'border' is  border color, 'bg' is  background color)
par(mfrow = c(2,2))
map("usa", col="tomato",  border="gray10", fill=TRUE, bg="gray30")
map("state", col="orange",  border="gray10", fill=TRUE, bg="gray30")
map("county", col="palegreen",  border="gray10", fill=TRUE, bg="gray30")
map("world", col="skyblue",  border="gray10", fill=TRUE, bg="gray30")
dev.off()
airports <- read.csv("./Data Files/Dataset3-Airlines-NODES.csv", header=TRUE)
flights <- read.csv("./Data Files/Dataset3-Airlines-EDGES.csv", header=TRUE, as.is=TRUE)
head(flights)
head(airports)
# Select only large airports: ones with more than 10 connections in the data.
tab <- table(flights$Source)
big.id <- names(tab)[tab>10]
airports <- airports[airports$ID %in% big.id,]
flights  <- flights[flights$Source %in% big.id &
flights$Target %in% big.id, ]
# Plot a map of the united states:
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
# Add a point on the map for each airport:
points(x=airports$longitude, y=airports$latitude, pch=19,
cex=airports$Visits/80, col="orange")
# Generate edge colors: lighter color means higher flight volume.
col.1 <- adjustcolor("orange red", alpha=0.4)
col.2 <- adjustcolor("orange", alpha=0.4)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
# For each flight, we will generate the coordinates of an arc that connects
# its star and end point, using gcIntermediate() from package 'geosphere'.
# Then we will plot that arc over the map using lines().
for(i in 1:nrow(flights))  {
node1 <- airports[airports$ID == flights[i,]$Source,]
node2 <- airports[airports$ID == flights[i,]$Target,]
arc <- gcIntermediate( c(node1[1,]$longitude, node1[1,]$latitude),
c(node2[1,]$longitude, node2[1,]$latitude),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
}
View(airports)
View(airports)
View(flights)
# ================ 1. Colors in R plots ================
#  -------~~ Colors --------
# In most R functions, you can use named colors, hex, or rgb values:
plot(x=1:10, y=rep(5,10), pch=19, cex=5, col="dark red")
points(x=1:10, y=rep(6, 10), pch=19, cex=5, col="#557799")
points(x=1:10, y=rep(4, 10), pch=19, cex=5, col=rgb(.25, .5, .3))
# In the simple base plot chart above, x and y are point coordinates, 'pch'
# is the point symbol shape, 'cex' is the point size, and 'col' is the color.
# To see the parameters for plotting in base R, check out ?par
# Some key ones include "bg" for background color, 'cex' for scaling text size,
# 'mar' for plot margins, 'new' for plotting witout clearing the previous plot,
# 'mfcol' & 'mfrow' split plotting space into rows and columns for multiple plots
?par
# To close the current graphics device clearing the plot and plot parameters, use:
dev.off()
# If you plan on using the built-in color names, here's what they are:
colors() # all colors
grep("blue", colors(), value=T) # colors that have 'blue' in the name
# You may notice that rgb here ranges from 0 to 1. While this is the R default,
# you can also set it for the more typical 0-255 range:
rgb(10, 100, 100, maxColorValue=255)
#  -------~~ Transparency --------
# We can also set the opacity/transparency using the parameter 'alpha' (range 0-1):
plot(x=1:5, y=rep(5,5), pch=19, cex=16, col=rgb(.25, .5, .3, alpha=.5), xlim=c(0,6))
# If we have a hex color representation, we can set the transparency alpha
# using 'adjustcolor' from package 'grDevices'. For fun, let's also set the
# the plot background to black using the par() function for graphical parameters.
# We could also set the margins in par() with mar=c(bottom, left, top, right).
par(bg="black")
col.tr <- grDevices::adjustcolor("#557799", alpha=0.7)
plot(x=1:5, y=rep(5,5), pch=19, cex=20, col=col.tr, xlim=c(0,6))
dev.off()
#  -------~~ Palettes --------
# In many cases, we need a number of contrasting colors, or multiple shades of a color.
# R comes with some predefined palette function that can generate those for us.
pal1 <- heat.colors(5, alpha=1)   # generate 5 colors from the heat palette, opaque
pal2 <- rainbow(5, alpha=.5)      # generate 5 colors from the heat palette, semi-transparent
plot(x=1:10, y=1:10, pch=19, cex=10, col=pal1)
par(new=TRUE) # tells R not to clear the first plot before adding the second one
plot(x=10:1, y=1:10, pch=19, cex=10, col=pal2)
# We can also generate our own gradients using colorRampPalette().
# Note that colorRampPalette returns a FUNCTION that we can use
# to generate as many colors from that palette as we need.
palf <- colorRampPalette(c("gray70", "dark red", "orange"))
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
# To add transparency to colorRampPalette, you need to add a parameter `alpha=TRUE`:
palf <- colorRampPalette(c(rgb(1,1,1, .2),rgb(.8,0,0, .7)), alpha=TRUE)
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
#  -------~~ ColorBrewer --------
# Finding good color combinations is a tough task - and the built-in R palettes
# are rather limited. Thankfully there are other available packages for this:
# install.packages("RColorBrewer")
library("RColorBrewer")
display.brewer.all()
# This package has one main function, called 'brewer.pal'.
# Using it, you just need to select the desired palette and a number of colors.
# Let's take a look at some of the RColorBrewer palettes:
display.brewer.pal(8, "Set3")
display.brewer.pal(8, "Spectral")
display.brewer.pal(8, "Blues")
# Plot figures using ColorBrewer
# We'll use par() to plot multiple figures.
# plot row by row: mfrow=c(number of rows, number of columns)
# plot column by column: mfcol=c(number of rows, number of columns)
par(mfrow=c(1,2)) # plot two figures - 1 row, 2 columns
pal3 <- brewer.pal(10, "Set3")
plot(x=10:1, y=10:1, pch=19, cex=6, col=pal3)
plot(x=10:1, y=10:1, pch=19, cex=6, col=rev(pal3)) # backwards
dev.off() # shut off the  graphic device to clear the two-figure configuration.
detach("package:RColorBrewer")
# ================ 2. Reading network data into 'igraph' ================
# Download an archive with the data files from http://bit.ly/polnet2018
# Clear your workspace by removing all objects returned by ls():
rm(list = ls())
# Set the working directory to the folder containing the workshop files:
setwd("G:/My Drive/DataFest 2019/CG/R/polnet2018")
# If you don't know the path to the folder and you're in RStudio, go to the
# "Session" menu -> "Set Working Directory" -> "To Source File Location"
library("igraph")
# Read in the data:
nodes <- read.csv("./Data files/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("./Data files/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
View(links)
View(links)
View(nodes)
View(nodes)
View(links)
View(links)
nodes <- read.csv("./Data files/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("./Data files/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
# nodes <- read.csv("./Data files/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
# links <- read.csv("./Data files/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
source('G:/My Drive/DataFest 2019/CG/R/polnet2018/Polnet 2018 R Network Visualization Workshop.R', echo=TRUE)
# ================ 1. Colors in R plots ================
#  -------~~ Colors --------
# In most R functions, you can use named colors, hex, or rgb values:
plot(x=1:10, y=rep(5,10), pch=19, cex=5, col="dark red")
points(x=1:10, y=rep(6, 10), pch=19, cex=5, col="#557799")
points(x=1:10, y=rep(4, 10), pch=19, cex=5, col=rgb(.25, .5, .3))
# In the simple base plot chart above, x and y are point coordinates, 'pch'
# is the point symbol shape, 'cex' is the point size, and 'col' is the color.
# To see the parameters for plotting in base R, check out ?par
# Some key ones include "bg" for background color, 'cex' for scaling text size,
# 'mar' for plot margins, 'new' for plotting witout clearing the previous plot,
# 'mfcol' & 'mfrow' split plotting space into rows and columns for multiple plots
?par
# To close the current graphics device clearing the plot and plot parameters, use:
dev.off()
# If you plan on using the built-in color names, here's what they are:
colors() # all colors
grep("blue", colors(), value=T) # colors that have 'blue' in the name
# You may notice that rgb here ranges from 0 to 1. While this is the R default,
# you can also set it for the more typical 0-255 range:
rgb(10, 100, 100, maxColorValue=255)
#  -------~~ Transparency --------
# We can also set the opacity/transparency using the parameter 'alpha' (range 0-1):
plot(x=1:5, y=rep(5,5), pch=19, cex=16, col=rgb(.25, .5, .3, alpha=.5), xlim=c(0,6))
# If we have a hex color representation, we can set the transparency alpha
# using 'adjustcolor' from package 'grDevices'. For fun, let's also set the
# the plot background to black using the par() function for graphical parameters.
# We could also set the margins in par() with mar=c(bottom, left, top, right).
par(bg="black")
col.tr <- grDevices::adjustcolor("#557799", alpha=0.7)
plot(x=1:5, y=rep(5,5), pch=19, cex=20, col=col.tr, xlim=c(0,6))
dev.off()
#  -------~~ Palettes --------
# In many cases, we need a number of contrasting colors, or multiple shades of a color.
# R comes with some predefined palette function that can generate those for us.
pal1 <- heat.colors(5, alpha=1)   # generate 5 colors from the heat palette, opaque
pal2 <- rainbow(5, alpha=.5)      # generate 5 colors from the heat palette, semi-transparent
plot(x=1:10, y=1:10, pch=19, cex=10, col=pal1)
par(new=TRUE) # tells R not to clear the first plot before adding the second one
plot(x=10:1, y=1:10, pch=19, cex=10, col=pal2)
# We can also generate our own gradients using colorRampPalette().
# Note that colorRampPalette returns a FUNCTION that we can use
# to generate as many colors from that palette as we need.
palf <- colorRampPalette(c("gray70", "dark red", "orange"))
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
# To add transparency to colorRampPalette, you need to add a parameter `alpha=TRUE`:
palf <- colorRampPalette(c(rgb(1,1,1, .2),rgb(.8,0,0, .7)), alpha=TRUE)
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
#  -------~~ ColorBrewer --------
# Finding good color combinations is a tough task - and the built-in R palettes
# are rather limited. Thankfully there are other available packages for this:
# install.packages("RColorBrewer")
library("RColorBrewer")
display.brewer.all()
# This package has one main function, called 'brewer.pal'.
# Using it, you just need to select the desired palette and a number of colors.
# Let's take a look at some of the RColorBrewer palettes:
display.brewer.pal(8, "Set3")
display.brewer.pal(8, "Spectral")
display.brewer.pal(8, "Blues")
# Plot figures using ColorBrewer
# We'll use par() to plot multiple figures.
# plot row by row: mfrow=c(number of rows, number of columns)
# plot column by column: mfcol=c(number of rows, number of columns)
par(mfrow=c(1,2)) # plot two figures - 1 row, 2 columns
pal3 <- brewer.pal(10, "Set3")
plot(x=10:1, y=10:1, pch=19, cex=6, col=pal3)
plot(x=10:1, y=10:1, pch=19, cex=6, col=rev(pal3)) # backwards
dev.off() # shut off the  graphic device to clear the two-figure configuration.
detach("package:RColorBrewer")
# ================ 2. Reading network data into 'igraph' ================
# ================ 1. Colors in R plots ================
#  -------~~ Colors --------
# In most R functions, you can use named colors, hex, or rgb values:
plot(x=1:10, y=rep(5,10), pch=19, cex=5, col="dark red")
points(x=1:10, y=rep(6, 10), pch=19, cex=5, col="#557799")
points(x=1:10, y=rep(4, 10), pch=19, cex=5, col=rgb(.25, .5, .3))
# In the simple base plot chart above, x and y are point coordinates, 'pch'
# is the point symbol shape, 'cex' is the point size, and 'col' is the color.
# To see the parameters for plotting in base R, check out ?par
# Some key ones include "bg" for background color, 'cex' for scaling text size,
# 'mar' for plot margins, 'new' for plotting witout clearing the previous plot,
# 'mfcol' & 'mfrow' split plotting space into rows and columns for multiple plots
?par
# To close the current graphics device clearing the plot and plot parameters, use:
dev.off()
# If you plan on using the built-in color names, here's what they are:
colors() # all colors
grep("blue", colors(), value=T) # colors that have 'blue' in the name
# You may notice that rgb here ranges from 0 to 1. While this is the R default,
# you can also set it for the more typical 0-255 range:
rgb(10, 100, 100, maxColorValue=255)
#  -------~~ Transparency --------
# We can also set the opacity/transparency using the parameter 'alpha' (range 0-1):
plot(x=1:5, y=rep(5,5), pch=19, cex=16, col=rgb(.25, .5, .3, alpha=.5), xlim=c(0,6))
# If we have a hex color representation, we can set the transparency alpha
# using 'adjustcolor' from package 'grDevices'. For fun, let's also set the
# the plot background to black using the par() function for graphical parameters.
# We could also set the margins in par() with mar=c(bottom, left, top, right).
par(bg="black")
col.tr <- grDevices::adjustcolor("#557799", alpha=0.7)
plot(x=1:5, y=rep(5,5), pch=19, cex=20, col=col.tr, xlim=c(0,6))
dev.off()
#  -------~~ Palettes --------
# In many cases, we need a number of contrasting colors, or multiple shades of a color.
# R comes with some predefined palette function that can generate those for us.
pal1 <- heat.colors(5, alpha=1)   # generate 5 colors from the heat palette, opaque
pal2 <- rainbow(5, alpha=.5)      # generate 5 colors from the heat palette, semi-transparent
plot(x=1:10, y=1:10, pch=19, cex=10, col=pal1)
par(new=TRUE) # tells R not to clear the first plot before adding the second one
plot(x=10:1, y=1:10, pch=19, cex=10, col=pal2)
# We can also generate our own gradients using colorRampPalette().
# Note that colorRampPalette returns a FUNCTION that we can use
# to generate as many colors from that palette as we need.
palf <- colorRampPalette(c("gray70", "dark red", "orange"))
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
# To add transparency to colorRampPalette, you need to add a parameter `alpha=TRUE`:
palf <- colorRampPalette(c(rgb(1,1,1, .2),rgb(.8,0,0, .7)), alpha=TRUE)
plot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10))
#  -------~~ ColorBrewer --------
# Finding good color combinations is a tough task - and the built-in R palettes
# are rather limited. Thankfully there are other available packages for this:
# install.packages("RColorBrewer")
library("RColorBrewer")
display.brewer.all()
# This package has one main function, called 'brewer.pal'.
# Using it, you just need to select the desired palette and a number of colors.
# Let's take a look at some of the RColorBrewer palettes:
display.brewer.pal(8, "Set3")
display.brewer.pal(8, "Spectral")
display.brewer.pal(8, "Blues")
# Plot figures using ColorBrewer
# We'll use par() to plot multiple figures.
# plot row by row: mfrow=c(number of rows, number of columns)
# plot column by column: mfcol=c(number of rows, number of columns)
par(mfrow=c(1,2)) # plot two figures - 1 row, 2 columns
pal3 <- brewer.pal(10, "Set3")
plot(x=10:1, y=10:1, pch=19, cex=6, col=pal3)
plot(x=10:1, y=10:1, pch=19, cex=6, col=rev(pal3)) # backwards
dev.off() # shut off the  graphic device to clear the two-figure configuration.
detach("package:RColorBrewer")
# ================ 2. Reading network data into 'igraph' ================
# ================ 10. Plotting networks on a geographic map ================
# The example below plots a network on a map using base R and mapping libraries.
# Note that for those familiar with it, the package 'ggplot2' may provide
# a more flexible way of doing this. Things there work similarly to below,
# but you would use borders() to plot the map and geom_path() for the edges.
rm(list = ls()) # clear the workspace
# In order to plot on a map, we'll need two additional packages.
# If you do not already have them, install those now:
# install.packages("maps")
# install.packages("geosphere")
library("maps")
library("geosphere")
# Package 'maps' has built-in maps it can plot for you. For example:
# ('col' is map fill, 'border' is  border color, 'bg' is  background color)
par(mfrow = c(2,2))
map("usa", col="tomato",  border="gray10", fill=TRUE, bg="gray30")
map("state", col="orange",  border="gray10", fill=TRUE, bg="gray30")
map("county", col="palegreen",  border="gray10", fill=TRUE, bg="gray30")
map("world", col="skyblue",  border="gray10", fill=TRUE, bg="gray30")
dev.off()
# The data we will use contains US airports and flights among them.
# The airport file includes info about latitude and longitude.
# If we did not have those, we could use 'geocode()' from 'ggmap'
# to get latitude and longitude for an address.
airports <- read.csv("./Data Files/Dataset3-Airlines-NODES.csv", header=TRUE)
flights <- read.csv("./Data Files/Dataset3-Airlines-EDGES.csv", header=TRUE, as.is=TRUE)
head(flights)
head(airports)
# Select only large airports: ones with more than 10 connections in the data.
tab <- table(flights$Source)
big.id <- names(tab)[tab>10]
airports <- airports[airports$ID %in% big.id,]
flights  <- flights[flights$Source %in% big.id &
flights$Target %in% big.id, ]
# Plot a map of the united states:
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)
# Add a point on the map for each airport:
points(x=airports$longitude, y=airports$latitude, pch=19,
cex=airports$Visits/80, col="orange")
# Generate edge colors: lighter color means higher flight volume.
col.1 <- adjustcolor("orange red", alpha=0.4)
col.2 <- adjustcolor("orange", alpha=0.4)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)
# For each flight, we will generate the coordinates of an arc that connects
# its star and end point, using gcIntermediate() from package 'geosphere'.
# Then we will plot that arc over the map using lines().
for(i in 1:nrow(flights))  {
node1 <- airports[airports$ID == flights[i,]$Source,]
node2 <- airports[airports$ID == flights[i,]$Target,]
arc <- gcIntermediate( c(node1[1,]$longitude, node1[1,]$latitude),
c(node2[1,]$longitude, node2[1,]$latitude),
n=1000, addStartEnd=TRUE )
edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))
lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
}
# ================ |-------------| ================
setwd("G:/My Drive/DataFest 2019/cg")
library(dplyr)
library(tidyverse)
library(readxl)
library(ggplot2)
setwd("G:/My Drive/DataFest 2019/cg")
library(dplyr)
library(tidyverse)
library(readxl)
library(ggplot2)
games <- read.csv(file="PayerByGameBySecond.csv", na.strings = "NA")
View(games)
View(games)
games <- read.csv(file="Player Distances Ran By Game.csv", na.strings = "NA")
View(games)
View(games)
